/**
 * Flowtype definitions for RhoTypes
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.8.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

import * as $protobuf from "protobufjs";
export interface IPar {
  sends?: ISend[];
  receives?: IReceive[];
  news?: INew[];
  exprs?: IExpr[];
  matches?: IMatch[];
  ids?: IGPrivate[];
  bundles?: IBundle[];
  connectives?: IConnective[];
  locallyFree?: Uint8Array;
  connective_used?: boolean;
}
declare export class Par implements IPar {
  constructor(properties?: IPar): this;
  sends: ISend[];
  receives: IReceive[];
  news: INew[];
  exprs: IExpr[];
  matches: IMatch[];
  ids: IGPrivate[];
  bundles: IBundle[];
  connectives: IConnective[];
  locallyFree: Uint8Array;
  connective_used: boolean;
  static create(properties?: IPar): Par;
  static encode(message: IPar, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IPar,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): Par;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): Par;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): Par;
  static toObject(
    message: Par,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface ITaggedContinuation {
  par_body?: IParWithRandom | null;
  scala_body_ref?: number | Long;
}
declare export class TaggedContinuation implements ITaggedContinuation {
  constructor(properties?: ITaggedContinuation): this;
  par_body: IParWithRandom | null;
  scala_body_ref: number | Long;
  tagged_cont: "par_body" | "scala_body_ref";
  static create(properties?: ITaggedContinuation): TaggedContinuation;
  static encode(
    message: ITaggedContinuation,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: ITaggedContinuation,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): TaggedContinuation;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): TaggedContinuation;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): TaggedContinuation;
  static toObject(
    message: TaggedContinuation,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IParWithRandom {
  body?: IPar | null;
  randomState?: Uint8Array | null;
}
declare export class ParWithRandom implements IParWithRandom {
  constructor(properties?: IParWithRandom): this;
  body: IPar | null;
  randomState: Uint8Array;
  static create(properties?: IParWithRandom): ParWithRandom;
  static encode(
    message: IParWithRandom,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: IParWithRandom,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): ParWithRandom;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): ParWithRandom;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): ParWithRandom;
  static toObject(
    message: ParWithRandom,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IPCost {
  cost?: number | Long;
}
declare export class PCost implements IPCost {
  constructor(properties?: IPCost): this;
  cost: number | Long;
  static create(properties?: IPCost): PCost;
  static encode(message: IPCost, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IPCost,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): PCost;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): PCost;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): PCost;
  static toObject(
    message: PCost,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IListParWithRandom {
  pars?: IPar[];
  randomState?: Uint8Array | null;
}
declare export class ListParWithRandom implements IListParWithRandom {
  constructor(properties?: IListParWithRandom): this;
  pars: IPar[];
  randomState: Uint8Array;
  static create(properties?: IListParWithRandom): ListParWithRandom;
  static encode(
    message: IListParWithRandom,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: IListParWithRandom,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): ListParWithRandom;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): ListParWithRandom;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): ListParWithRandom;
  static toObject(
    message: ListParWithRandom,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IListParWithRandomAndPhlos {
  pars?: IPar[];
  randomState?: Uint8Array | null;
  cost?: number | Long;
}
declare export class ListParWithRandomAndPhlos
  implements IListParWithRandomAndPhlos {
  constructor(properties?: IListParWithRandomAndPhlos): this;
  pars: IPar[];
  randomState: Uint8Array;
  cost: number | Long;
  static create(
    properties?: IListParWithRandomAndPhlos
  ): ListParWithRandomAndPhlos;
  static encode(
    message: IListParWithRandomAndPhlos,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: IListParWithRandomAndPhlos,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): ListParWithRandomAndPhlos;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): ListParWithRandomAndPhlos;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): ListParWithRandomAndPhlos;
  static toObject(
    message: ListParWithRandomAndPhlos,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IVar {
  bound_var?: number;
  free_var?: number;
  wildcard?: Var$IWildcardMsg | null;
}
declare export class Var implements IVar {
  constructor(properties?: IVar): this;
  bound_var: number;
  free_var: number;
  wildcard: Var$IWildcardMsg | null;
  var_instance: "bound_var" | "free_var" | "wildcard";
  static create(properties?: IVar): typeof Var;
  static encode(message: IVar, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IVar,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): Var;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): Var;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): typeof Var;
  static toObject(
    message: typeof Var,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
//??? declare var Var: typeof npm$namespace$Var;

declare var npm$namespace$Var: {
  WildcardMsg: typeof Var$WildcardMsg
};
declare interface Var$IWildcardMsg {}

declare class Var$WildcardMsg implements Var$IWildcardMsg {
  constructor(properties?: Var$IWildcardMsg): this;
  static create(properties?: Var$IWildcardMsg): Var$WildcardMsg;
  static encode(
    message: Var$IWildcardMsg,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: Var$IWildcardMsg,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): Var$WildcardMsg;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): Var$WildcardMsg;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): Var$WildcardMsg;
  static toObject(
    message: Var$WildcardMsg,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IBundle {
  body?: IPar | null;
  writeFlag?: boolean;
  readFlag?: boolean;
}
declare export class Bundle implements IBundle {
  constructor(properties?: IBundle): this;
  body: IPar | null;
  writeFlag: boolean;
  readFlag: boolean;
  static create(properties?: IBundle): Bundle;
  static encode(message: IBundle, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IBundle,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): Bundle;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): Bundle;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): Bundle;
  static toObject(
    message: Bundle,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface ISend {
  chan?: IPar | null;
  data?: IPar[];
  persistent?: boolean;
  locallyFree?: Uint8Array | null;
  connective_used?: boolean;
}
declare export class Send implements ISend {
  constructor(properties?: ISend): this;
  chan: IPar | null;
  data: IPar[];
  persistent: boolean;
  locallyFree: Uint8Array;
  connective_used: boolean;
  static create(properties?: ISend): Send;
  static encode(message: ISend, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: ISend,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): Send;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): Send;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): Send;
  static toObject(
    message: Send,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IReceiveBind {
  patterns?: IPar[];
  source?: IPar | null;
  remainder?: IVar | null;
  freeCount?: number;
}
declare export class ReceiveBind implements IReceiveBind {
  constructor(properties?: IReceiveBind): this;
  patterns: IPar[];
  source: IPar | null;
  remainder: IVar | null;
  freeCount: number;
  static create(properties?: IReceiveBind): ReceiveBind;
  static encode(
    message: IReceiveBind,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: IReceiveBind,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): ReceiveBind;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): ReceiveBind;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): ReceiveBind;
  static toObject(
    message: ReceiveBind,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IBindPattern {
  patterns?: IPar[];
  remainder?: IVar | null;
  freeCount?: number;
}
declare export class BindPattern implements IBindPattern {
  constructor(properties?: IBindPattern): this;
  patterns: IPar[];
  remainder: IVar | null;
  freeCount: number;
  static create(properties?: IBindPattern): BindPattern;
  static encode(
    message: IBindPattern,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: IBindPattern,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): BindPattern;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): BindPattern;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): BindPattern;
  static toObject(
    message: BindPattern,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IListBindPatterns {
  patterns?: IBindPattern[];
}
declare export class ListBindPatterns implements IListBindPatterns {
  constructor(properties?: IListBindPatterns): this;
  patterns: IBindPattern[];
  static create(properties?: IListBindPatterns): ListBindPatterns;
  static encode(
    message: IListBindPatterns,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: IListBindPatterns,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): ListBindPatterns;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): ListBindPatterns;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): ListBindPatterns;
  static toObject(
    message: ListBindPatterns,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IReceive {
  binds?: IReceiveBind[];
  body?: IPar | null;
  persistent?: boolean;
  bindCount?: number;
  locallyFree?: Uint8Array | null;
  connective_used?: boolean;
}
declare export class Receive implements IReceive {
  constructor(properties?: IReceive): this;
  binds: IReceiveBind[];
  body: IPar | null;
  persistent: boolean;
  bindCount: number;
  locallyFree: Uint8Array;
  connective_used: boolean;
  static create(properties?: IReceive): Receive;
  static encode(message: IReceive, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IReceive,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): Receive;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): Receive;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): Receive;
  static toObject(
    message: Receive,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface INew {
  bindCount?: number;
  p?: IPar | null;
  uri?: string[];
  locallyFree?: Uint8Array | null;
}
declare export class New implements INew {
  constructor(properties?: INew): this;
  bindCount: number;
  p: IPar | null;
  uri: string[];
  locallyFree: Uint8Array;
  static create(properties?: INew): New;
  static encode(message: INew, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: INew,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): New;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): New;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): New;
  static toObject(
    message: New,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IMatchCase {
  pattern?: IPar | null;
  source?: IPar | null;
  freeCount?: number;
}
declare export class MatchCase implements IMatchCase {
  constructor(properties?: IMatchCase): this;
  pattern: IPar | null;
  source: IPar | null;
  freeCount: number;
  static create(properties?: IMatchCase): MatchCase;
  static encode(
    message: IMatchCase,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: IMatchCase,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): MatchCase;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): MatchCase;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): MatchCase;
  static toObject(
    message: MatchCase,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IMatch {
  target?: IPar | null;
  cases?: IMatchCase[];
  locallyFree?: Uint8Array | null;
  connective_used?: boolean;
}
declare export class Match implements IMatch {
  constructor(properties?: IMatch): this;
  target: IPar | null;
  cases: IMatchCase[];
  locallyFree: Uint8Array;
  connective_used: boolean;
  static create(properties?: IMatch): Match;
  static encode(message: IMatch, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IMatch,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): Match;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): Match;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): Match;
  static toObject(
    message: Match,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IExpr {
  g_bool?: boolean;
  g_int?: number | Long;
  g_string?: string;
  g_uri?: string;
  g_byte_array?: Uint8Array | null;
  e_not_body?: IENot | null;
  e_neg_body?: IENeg | null;
  e_mult_body?: IEMult | null;
  e_div_body?: IEDiv | null;
  e_plus_body?: IEPlus | null;
  e_minus_body?: IEMinus | null;
  e_lt_body?: IELt | null;
  e_lte_body?: IELte | null;
  e_gt_body?: IEGt | null;
  e_gte_body?: IEGte | null;
  e_eq_body?: IEEq | null;
  e_neq_body?: IENeq | null;
  e_and_body?: IEAnd | null;
  e_or_body?: IEOr | null;
  e_var_body?: IEVar | null;
  e_list_body?: IEList | null;
  e_tuple_body?: IETuple | null;
  e_set_body?: IESet | null;
  e_map_body?: IEMap | null;
  e_method_body?: IEMethod | null;
  e_matches_body?: IEMatches | null;
  e_percent_percent_body?: IEPercentPercent | null;
  e_plus_plus_body?: IEPlusPlus | null;
  e_minus_minus_body?: IEMinusMinus | null;
}
declare export class Expr implements IExpr {
  constructor(properties?: IExpr): this;
  g_bool: boolean;
  g_int: number | Long;
  g_string: string;
  g_uri: string;
  g_byte_array: Uint8Array;
  e_not_body: IENot | null;
  e_neg_body: IENeg | null;
  e_mult_body: IEMult | null;
  e_div_body: IEDiv | null;
  e_plus_body: IEPlus | null;
  e_minus_body: IEMinus | null;
  e_lt_body: IELt | null;
  e_lte_body: IELte | null;
  e_gt_body: IEGt | null;
  e_gte_body: IEGte | null;
  e_eq_body: IEEq | null;
  e_neq_body: IENeq | null;
  e_and_body: IEAnd | null;
  e_or_body: IEOr | null;
  e_var_body: IEVar | null;
  e_list_body: IEList | null;
  e_tuple_body: IETuple | null;
  e_set_body: IESet | null;
  e_map_body: IEMap | null;
  e_method_body: IEMethod | null;
  e_matches_body: IEMatches | null;
  e_percent_percent_body: IEPercentPercent | null;
  e_plus_plus_body: IEPlusPlus | null;
  e_minus_minus_body: IEMinusMinus | null;
  expr_instance:
    | "g_bool"
    | "g_int"
    | "g_string"
    | "g_uri"
    | "g_byte_array"
    | "e_not_body"
    | "e_neg_body"
    | "e_mult_body"
    | "e_div_body"
    | "e_plus_body"
    | "e_minus_body"
    | "e_lt_body"
    | "e_lte_body"
    | "e_gt_body"
    | "e_gte_body"
    | "e_eq_body"
    | "e_neq_body"
    | "e_and_body"
    | "e_or_body"
    | "e_var_body"
    | "e_list_body"
    | "e_tuple_body"
    | "e_set_body"
    | "e_map_body"
    | "e_method_body"
    | "e_matches_body"
    | "e_percent_percent_body"
    | "e_plus_plus_body"
    | "e_minus_minus_body";
  static create(properties?: IExpr): Expr;
  static encode(message: IExpr, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IExpr,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): Expr;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): Expr;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): Expr;
  static toObject(
    message: Expr,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IEList {
  ps?: IPar[];
  locallyFree?: Uint8Array | null;
  connective_used?: boolean;
  remainder?: IVar | null;
}
declare export class EList implements IEList {
  constructor(properties?: IEList): this;
  ps: IPar[];
  locallyFree: Uint8Array;
  connective_used: boolean;
  remainder: IVar | null;
  static create(properties?: IEList): EList;
  static encode(message: IEList, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IEList,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): EList;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): EList;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): EList;
  static toObject(
    message: EList,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IETuple {
  ps?: IPar[] | null;
  locallyFree?: Uint8Array | null;
  connective_used?: boolean | null;
}
declare export class ETuple implements IETuple {
  constructor(properties?: IETuple): this;
  ps: IPar[] | null;
  locallyFree: Uint8Array;
  connective_used: boolean | null;
  static create(properties?: IETuple): ETuple;
  static encode(message: IETuple, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IETuple,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): ETuple;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): ETuple;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): ETuple;
  static toObject(
    message: ETuple,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IESet {
  ps?: IPar[] | null;
  locallyFree?: Uint8Array | null;
  connective_used?: boolean | null;
  remainder?: IVar | null;
}
declare export class ESet implements IESet {
  constructor(properties?: IESet): this;
  ps: IPar[] | null;
  locallyFree: Uint8Array;
  connective_used: boolean | null;
  remainder: IVar | null;
  static create(properties?: IESet): ESet;
  static encode(message: IESet, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IESet,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): ESet;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): ESet;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): ESet;
  static toObject(
    message: ESet,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IEMap {
  kvs?: IKeyValuePair[] | null;
  locallyFree?: Uint8Array | null;
  connective_used?: boolean | null;
  remainder?: IVar | null;
}
declare export class EMap implements IEMap {
  constructor(properties?: IEMap): this;
  kvs: IKeyValuePair[] | null;
  locallyFree: Uint8Array;
  connective_used: boolean | null;
  remainder: IVar | null;
  static create(properties?: IEMap): EMap;
  static encode(message: IEMap, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IEMap,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): EMap;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): EMap;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): EMap;
  static toObject(
    message: EMap,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IEMethod {
  methodName?: string | null;
  target?: IPar | null;
  arguments?: IPar[] | null;
  locallyFree?: Uint8Array | null;
  connective_used?: boolean;
}
declare export class EMethod implements IEMethod {
  constructor(properties?: IEMethod): this;
  methodName: string | null;
  target: IPar | null;
  arguments: IPar[] | null;
  locallyFree: Uint8Array;
  connective_used: boolean;
  static create(properties?: IEMethod): EMethod;
  static encode(message: IEMethod, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IEMethod,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): EMethod;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): EMethod;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): EMethod;
  static toObject(
    message: EMethod,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IKeyValuePair {
  key?: IPar | null;
  value?: IPar | null;
}
declare export class KeyValuePair implements IKeyValuePair {
  constructor(properties?: IKeyValuePair): this;
  key: IPar | null;
  value: IPar | null;
  static create(properties?: IKeyValuePair): KeyValuePair;
  static encode(
    message: IKeyValuePair,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: IKeyValuePair,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): KeyValuePair;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): KeyValuePair;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): KeyValuePair;
  static toObject(
    message: KeyValuePair,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IEVar {
  v?: IVar | null;
}
declare export class EVar implements IEVar {
  constructor(properties?: IEVar): this;
  v: IVar | null;
  static create(properties?: IEVar): EVar;
  static encode(message: IEVar, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IEVar,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): EVar;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): EVar;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): EVar;
  static toObject(
    message: EVar,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IENot {
  p?: IPar | null;
}
declare export class ENot implements IENot {
  constructor(properties?: IENot): this;
  p: IPar | null;
  static create(properties?: IENot): ENot;
  static encode(message: IENot, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IENot,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): ENot;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): ENot;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): ENot;
  static toObject(
    message: ENot,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IENeg {
  p?: IPar | null;
}
declare export class ENeg implements IENeg {
  constructor(properties?: IENeg): this;
  p: IPar | null;
  static create(properties?: IENeg): ENeg;
  static encode(message: IENeg, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IENeg,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): ENeg;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): ENeg;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): ENeg;
  static toObject(
    message: ENeg,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IEMult {
  p1?: IPar | null;
  p2?: IPar | null;
}
declare export class EMult implements IEMult {
  constructor(properties?: IEMult): this;
  p1: IPar | null;
  p2: IPar | null;
  static create(properties?: IEMult): EMult;
  static encode(message: IEMult, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IEMult,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): EMult;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): EMult;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): EMult;
  static toObject(
    message: EMult,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IEDiv {
  p1?: IPar | null;
  p2?: IPar | null;
}
declare export class EDiv implements IEDiv {
  constructor(properties?: IEDiv): this;
  p1: IPar | null;
  p2: IPar | null;
  static create(properties?: IEDiv): EDiv;
  static encode(message: IEDiv, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IEDiv,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): EDiv;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): EDiv;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): EDiv;
  static toObject(
    message: EDiv,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IEPlus {
  p1?: IPar | null;
  p2?: IPar | null;
}
declare export class EPlus implements IEPlus {
  constructor(properties?: IEPlus): this;
  p1: IPar | null;
  p2: IPar | null;
  static create(properties?: IEPlus): EPlus;
  static encode(message: IEPlus, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IEPlus,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): EPlus;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): EPlus;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): EPlus;
  static toObject(
    message: EPlus,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IEMinus {
  p1?: IPar | null;
  p2?: IPar | null;
}
declare export class EMinus implements IEMinus {
  constructor(properties?: IEMinus): this;
  p1: IPar | null;
  p2: IPar | null;
  static create(properties?: IEMinus): EMinus;
  static encode(message: IEMinus, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IEMinus,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): EMinus;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): EMinus;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): EMinus;
  static toObject(
    message: EMinus,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IELt {
  p1?: IPar | null;
  p2?: IPar | null;
}
declare export class ELt implements IELt {
  constructor(properties?: IELt): this;
  p1: IPar | null;
  p2: IPar | null;
  static create(properties?: IELt): ELt;
  static encode(message: IELt, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IELt,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): ELt;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): ELt;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): ELt;
  static toObject(
    message: ELt,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IELte {
  p1?: IPar | null;
  p2?: IPar | null;
}
declare export class ELte implements IELte {
  constructor(properties?: IELte): this;
  p1: IPar | null;
  p2: IPar | null;
  static create(properties?: IELte): ELte;
  static encode(message: IELte, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IELte,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): ELte;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): ELte;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): ELte;
  static toObject(
    message: ELte,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IEGt {
  p1?: IPar | null;
  p2?: IPar | null;
}
declare export class EGt implements IEGt {
  constructor(properties?: IEGt): this;
  p1: IPar | null;
  p2: IPar | null;
  static create(properties?: IEGt): EGt;
  static encode(message: IEGt, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IEGt,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): EGt;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): EGt;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): EGt;
  static toObject(
    message: EGt,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IEGte {
  p1?: IPar | null;
  p2?: IPar | null;
}
declare export class EGte implements IEGte {
  constructor(properties?: IEGte): this;
  p1: IPar | null;
  p2: IPar | null;
  static create(properties?: IEGte): EGte;
  static encode(message: IEGte, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IEGte,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): EGte;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): EGte;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): EGte;
  static toObject(
    message: EGte,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IEEq {
  p1?: IPar | null;
  p2?: IPar | null;
}
declare export class EEq implements IEEq {
  constructor(properties?: IEEq): this;
  p1: IPar | null;
  p2: IPar | null;
  static create(properties?: IEEq): EEq;
  static encode(message: IEEq, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IEEq,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): EEq;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): EEq;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): EEq;
  static toObject(
    message: EEq,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IENeq {
  p1?: IPar | null;
  p2?: IPar | null;
}
declare export class ENeq implements IENeq {
  constructor(properties?: IENeq): this;
  p1: IPar | null;
  p2: IPar | null;
  static create(properties?: IENeq): ENeq;
  static encode(message: IENeq, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IENeq,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): ENeq;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): ENeq;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): ENeq;
  static toObject(
    message: ENeq,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IEAnd {
  p1?: IPar | null;
  p2?: IPar | null;
}
declare export class EAnd implements IEAnd {
  constructor(properties?: IEAnd): this;
  p1: IPar | null;
  p2: IPar | null;
  static create(properties?: IEAnd): EAnd;
  static encode(message: IEAnd, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IEAnd,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): EAnd;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): EAnd;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): EAnd;
  static toObject(
    message: EAnd,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IEOr {
  p1?: IPar | null;
  p2?: IPar | null;
}
declare export class EOr implements IEOr {
  constructor(properties?: IEOr): this;
  p1: IPar | null;
  p2: IPar | null;
  static create(properties?: IEOr): EOr;
  static encode(message: IEOr, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IEOr,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): EOr;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): EOr;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): EOr;
  static toObject(
    message: EOr,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IEMatches {
  target?: IPar | null;
  pattern?: IPar | null;
}
declare export class EMatches implements IEMatches {
  constructor(properties?: IEMatches): this;
  target: IPar | null;
  pattern: IPar | null;
  static create(properties?: IEMatches): EMatches;
  static encode(
    message: IEMatches,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: IEMatches,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): EMatches;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): EMatches;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): EMatches;
  static toObject(
    message: EMatches,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IEPercentPercent {
  p1?: IPar | null;
  p2?: IPar | null;
}
declare export class EPercentPercent implements IEPercentPercent {
  constructor(properties?: IEPercentPercent): this;
  p1: IPar | null;
  p2: IPar | null;
  static create(properties?: IEPercentPercent): EPercentPercent;
  static encode(
    message: IEPercentPercent,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: IEPercentPercent,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): EPercentPercent;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): EPercentPercent;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): EPercentPercent;
  static toObject(
    message: EPercentPercent,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IEPlusPlus {
  p1?: IPar | null;
  p2?: IPar | null;
}
declare export class EPlusPlus implements IEPlusPlus {
  constructor(properties?: IEPlusPlus): this;
  p1: IPar | null;
  p2: IPar | null;
  static create(properties?: IEPlusPlus): EPlusPlus;
  static encode(
    message: IEPlusPlus,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: IEPlusPlus,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): EPlusPlus;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): EPlusPlus;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): EPlusPlus;
  static toObject(
    message: EPlusPlus,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IEMinusMinus {
  p1?: IPar | null;
  p2?: IPar | null;
}
declare export class EMinusMinus implements IEMinusMinus {
  constructor(properties?: IEMinusMinus): this;
  p1: IPar | null;
  p2: IPar | null;
  static create(properties?: IEMinusMinus): EMinusMinus;
  static encode(
    message: IEMinusMinus,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: IEMinusMinus,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): EMinusMinus;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): EMinusMinus;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): EMinusMinus;
  static toObject(
    message: EMinusMinus,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IConnective {
  conn_and_body?: IConnectiveBody | null;
  conn_or_body?: IConnectiveBody | null;
  conn_not_body?: IPar | null;
  var_ref_body?: IVarRef | null;
  conn_bool?: boolean | null;
  conn_int?: boolean | null;
  conn_string?: boolean | null;
  conn_uri?: boolean | null;
  conn_byte_array?: boolean | null;
}
declare export class Connective implements IConnective {
  constructor(properties?: IConnective): this;
  conn_and_body: IConnectiveBody | null;
  conn_or_body: IConnectiveBody | null;
  conn_not_body: IPar | null;
  var_ref_body: IVarRef | null;
  conn_bool: boolean | null;
  conn_int: boolean | null;
  conn_string: boolean | null;
  conn_uri: boolean | null;
  conn_byte_array: boolean | null;
  connective_instance:
    | "conn_and_body"
    | "conn_or_body"
    | "conn_not_body"
    | "var_ref_body"
    | "conn_bool"
    | "conn_int"
    | "conn_string"
    | "conn_uri"
    | "conn_byte_array";
  static create(properties?: IConnective): Connective;
  static encode(
    message: IConnective,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: IConnective,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): Connective;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): Connective;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): Connective;
  static toObject(
    message: Connective,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IVarRef {
  index?: number;
  depth?: number;
}
declare export class VarRef implements IVarRef {
  constructor(properties?: IVarRef): this;
  index: number;
  depth: number;
  static create(properties?: IVarRef): VarRef;
  static encode(message: IVarRef, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IVarRef,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): VarRef;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): VarRef;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): VarRef;
  static toObject(
    message: VarRef,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IConnectiveBody {
  ps?: IPar[] | null;
}
declare export class ConnectiveBody implements IConnectiveBody {
  constructor(properties?: IConnectiveBody): this;
  ps: IPar[] | null;
  static create(properties?: IConnectiveBody): ConnectiveBody;
  static encode(
    message: IConnectiveBody,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: IConnectiveBody,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): ConnectiveBody;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): ConnectiveBody;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): ConnectiveBody;
  static toObject(
    message: ConnectiveBody,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
export interface IGPrivate {
  id?: Uint8Array | null;
}
declare export class GPrivate implements IGPrivate {
  constructor(properties?: IGPrivate): this;
  id: Uint8Array;
  static create(properties?: IGPrivate): GPrivate;
  static encode(
    message: IGPrivate,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: IGPrivate,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): GPrivate;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): GPrivate;
  static verify(message: {
    [k: string]: any
  }): string | null;
  static fromObject(object: {
    [k: string]: any
  }): GPrivate;
  static toObject(
    message: GPrivate,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any
  };
  toJSON(): {
    [k: string]: any
  };
}
